Waiting for resource to join

Today's topic:
1) JIRA
2) Terraform


What is JIRA? and why we need it?
JIRA is basically a project management tool in which we are documenting our requirement.

EPIC

STORY/USER STORY

TASK

SUBTASK

BUG

Epics: Epics represent large bodies of work that can be broken down into smaller, manageable pieces called Stories. They serve as high-level containers for related Stories and provide a comprehensive view of project progress and goals.

Stories: Also known as User Stories, they represent user-facing requirements and provide context for the development team. Stories articulate how a software feature will deliver value to the end-user and serve as the building blocks of Epics.

Tasks: Tasks are detailed units of work that must be completed to achieve the objectives outlined in the Stories. They represent the individual steps and actions required to implement a feature or complete a Story.

My requirement is- I want to create E-learning portal that has 3 components- 1) Frontend, 2) Middleware and 3) Backend.

EPIC: Creating E-learning portal

STORY1: Impmenting Frontend services
STORY2: Implementing middleware services
STORY3: Implementing backend services

TASK/SUBTASK:
TASK1: Installtion and configuration fo Database
TASK2: Database management

BUG: When we see some issue,

Support: When there is a problem, but we are not sure about it's cause.

Terraform commands
==================
Terraform init
terraform validate
terraform apply
terraform destroy
terraform plan

For using terraform we assume that you are master in cloud which you are using.


requirement: Create Azure webapp server.

Azure resource group, Azure resource plan, Azure resource webapp

> Whatever is possible in cloud with manual steps you can automate

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}

resource "azurerm_app_service_plan" "example" {
  name                = "example-appserviceplan"
  location            = azurerm_resource_group.example.location
  resource_group_name = azurerm_resource_group.example.name

  sku {
    tier = "Standard"
    size = "S1"
  }
}

resource "azurerm_app_service" "example" {
  name                = "example-app-service"
  location            = azurerm_resource_group.example.location
  resource_group_name = azurerm_resource_group.example.name
  app_service_plan_id = azurerm_app_service_plan.example.id

  site_config {
    dotnet_framework_version = "v4.0"
    scm_type                 = "LocalGit"
  }

  app_settings = {
    "SOME_KEY" = "some-value"
  }

  connection_string {
    name  = "Database"
    type  = "SQLServer"
    value = "Server=some-server.mydomain.com;Integrated Security=SSPI"
  }
}



In terraform we have 4 component:
1) Provider[Azure]
2) Resource[What resource we want to create]
3) Input
4) Output

Terraform init> 
terraform {
  required_providers {
    alicloud = {
      source = "aliyun/alicloud"
      version = "1.217.0"
    }
  }
}

provider "alicloud" {
  # Configuration options
}

ubuntu $ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding aliyun/alicloud versions matching "1.217.0"...
- Installing aliyun/alicloud v1.217.0...
- Installed aliyun/alicloud v1.217.0 (signed by a HashiCorp partner, key ID 47422B4AA9FA381B)

Partner and community providers are signed by their developers.
If you'd like to know more about provider signing, you can read about it here:
https://www.terraform.io/docs/cli/plugins/signing.html

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.

Backend:
========
Suppose, we 3 are working on team, and we need create infrastucture by terraform

>>>terraform apply<<<
Lets say all 3 of us executed in same time

Terraform uses concept of backend to check state of required configuration.

In terraform infrastucture would be store in 3 places-
1) Main.tf
2) statefile
3) cloudprovider


resource "azurerm_app_service_plan" "example" {
  name                = "example-appserviceplan"
  location            = azurerm_resource_group.example.location
  resource_group_name = azurerm_resource_group.example.name

  sku {
    tier = "Standard"
    size = "S3"
  }
}

Step1: Infrasture code is written in main.tf and infra created in cloud provider.

Step2: lets I want to change size from S3 to standard

provider "azurerm" {
  features {}
}

resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
}

resource "azurerm_storage_account" "example" {
  name                     = "examplesa"
  resource_group_name      = azurerm_resource_group.example.name
  location                 = azurerm_resource_group.example.location
  account_tier             = "Standard"
  account_replication_type = "LRS"
}

resource "azurerm_mssql_server" "example" {
  name                         = "example-sqlserver"
  resource_group_name          = azurerm_resource_group.example.name
  location                     = azurerm_resource_group.example.location
  version                      = "12.0"
  administrator_login          = "4dm1n157r470r"
  administrator_login_password = "4-v3ry-53cr37-p455w0rd"
}

resource "azurerm_mssql_database" "example" { #MyDb
  name           = "example-db"
  server_id      = azurerm_mssql_server.example.id
  collation      = "SQL_Latin1_General_CP1_CI_AS"
  license_type   = "LicenseIncluded"
  max_size_gb    = 4
  read_scale     = true
  sku_name       = "S0"
  zone_redundant = true
  enclave_type   = "VBS"

  tags = {
    foo = "bar"
  }

  # prevent the possibility of accidental data loss
  lifecycle {
    prevent_destroy = true
  }
}


Tomorrow: Jenkins-2
Dayafter: Azure DevOps
Friday: Ansible, monitoring, SRE-2
K8s- 5classs
Lastclass: interview support

































































